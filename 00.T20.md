# 1. 文档修订记录

|版本|修订日期|修订内容|修订人|
|---|---|---|---|
|V1.0|2025-03-03|初版发布|黄伟|

# 2. 概述

## 2.1 协议简介
* 本设备支持基于RS485物理层的Modbus RTU协议，协议标准为**Modbus Application Protocol v1.1b**
* 本设备为从机（Slave），响应主站（Master）的读/写请求

## 2.2 通信参数

|参数|默认值|说明|
|---|---|---|
|波特率|9600 bps|支持可配置（如4800/19200等）|
|数据位|8 bits||
|停止位|1 bit||
|校验方式|无校验|可选：无校验/奇校验/偶校验|
|设备地址|1~247|默认地址：1|
|响应超时|300 ms|主站等待从机响应的超时时间|

# 3. 物理层规范（RS485）

## 3.1 接口定义
|引脚|信号名称|说明|
|---|---|---|
|A|RS485+|差分信号正极|
|B|RS485-|差分信号负极|
|GND|地线|信号参考地|

## 3.2 电器特性
* 符合RS485 TIA/EIA-485标准。
* 最大传输距离：1200米（波特率≤19200时）。
* 终端电阻：建议在总线两端并联120Ω电阻。

# 4. 协议层规范（Modbus RTU）

## 4.1 数据帧格式
|字段|长度|说明|
|---|---|---|
|从机地址|1 Byte|设备地址范围1~247|
|功能码|1 Byte|操作类型（读/写）|
|数据域|N Bytes|寄存器地址、数据等|
|CRC校验|2 Bytes|循环冗余校验（低字节在前）|

## 4.2 支持的Modbus功能码
|功能码|名称|说明|
|---|---|---|
|0x03|Read Holding Registers|读取保持寄存器|
|0x04|Read Input Registers|读取输入寄存器|
|0x06|Write Single Register|写单个保持寄存器|
|0x10|Write Multiple Register|写多个保持寄存器|


# 5. 寄存器地址映射表

## 5.1 寄存器定义
|寄存器地址|数据类型|读写权限|名称|单位|范围|说明|
|---|---|---|---|---|---|---|
|0x0000|uint8|只读|急停触发状态||0:未触发，1:触发||
|0x0001|uint8|只读|起降平台通信状态||0:离线，1:在线||
|0x0002|uint8|只读|起降平台工作状态||0:未知，1:复位中，2:空闲，3:接机准备，4:接机等待，5:接机中，6:驻机，7:起飞准备，8:起飞等待，99:故障||
|0x0003|uint16|只读|起降平台故障代码||||
|0x0004|uint8|只读|防雨盖在线状态||0:离线，1:在线，255:无该模块||
|0x0005|uint8|只读|防雨盖工作状态||0:未知，1:关闭，2:打开，4:打开中，5:关闭中，6:故障||
|0x0006|uint8|只读|归中杆在线状态||0:离线，1:在线，255:无该模块||
|0x0007|uint8|只读|归中杆工作状态||0:未知，1:释放，2:收紧，3:第一组收紧中，4:第二组收紧中，5:释放中，6:故障||
|0x0008|uint8|只读|装卸货口在线状态||0:离线，1:在线，255:无该模块||
|0x0009|uint8|只读|装卸货口工作状态||0:未知，1:关闭，2:打开，4:打开中，5:关闭中，6:故障||
|0x000A|uint8|只读|充电模块在线状态||0:离线，1:在线，255:无该模块||
|0x000B|uint8|只读|电池检测状态||0:未知，1:检测到电池，2:未检测到电池||
|0x000C|uint8|只读|电池开关机状态||0:未知，1:开机，2:关机||
|0x000D|uint8|只读|充电状态||0:未充电，1:充电初始化，2:关机充电，3:开机充电，4:充电完成，5:冷却等待，6:故障||
|0x000E|uint16|只读|充电电压|0.01V|0~10000|5200代表52.00V|
|0x000F|uint16|只读|充电电流|0.01A|0~10000|2000代表20.00A|
|0x0010|uint8|只读|充电百分比|%|0~100||
|0x0011|uint16|只读|充电时长|秒 / s|0~65535||
|0x0012|uint8|只读|起降平台升降连接状态||0:离线，1:在线，255:无该模块||
|0x0013|uint8|只读|起降平台升降工作状态||0:未知，1:顶部，2:底部，3:中间，4:上升中，5:下降中，6:故障||
|0x0020|uint8|只读|包裹处理机构在线状态||0:离线，1:在线，255:无该模块||
|0x0021|uint8|只读|包裹处理机构工作状态||0:空闲，1:复位中，2:寄件处理，3:取件处理，4:下货准备，5:下货中，6:上货中，99:故障|上货完成后，机构处于上货位置，需要执行复位指令，进入复位状态。|
|0x0022|uint16|只读|包裹处理机构故障码||||
|0x0030|uint8|只读|储物柜总槽数||0~64||
|0x0031|uint8|只读|储物柜空槽数||||
|0x0032|uint8|只读|储物柜非空槽数||||
|0x0033|uint8|只读|储物柜故障槽数||||
|0x0034|uint16|只读|0~15号槽位非空标志|||二进制相应位0代表空，1代表非空|
|0x0035|uint16|只读|16~31号槽位非空标志||||
|0x0036|uint16|只读|32~47号槽位非空标志||||
|0x0037|uint16|只读|48~63号槽位非空标志||||
|0x0038|uint16|只读|0~15号槽位故障标志|||二进制相应位0代表正常，1代表故障|
|0x0039|uint16|只读|16~31号槽位故障标志||||
|0x003A|uint16|只读|32~47号槽位故障标志||||
|0x003B|uint16|只读|48~63号槽位故障标志||||
|0x0040|uint8|只读|存取件口连接状态||0:离线，1:在线，255:无该模块||
|0x0041|uint8|只读|存取口门状态||0:未知，1:关闭，2:打开，4:打开中，5:关闭中，6:故障||
|0x8000|uint8|读写|指令下发||0:预留，1:接机准备，2:接机，3:起飞准备，4:开始一键充电，5:软急停，6:取消接机准备，7:取消起飞准备，8:复位起降平台，101:打开盖子，102:关闭盖子，103:松归中杆，104:收归中杆，105:开上下货窗，106:关上下货口窗，107:升起降平台升降，108:降起降平台升降，109:开无人机，110:关无人机，111:开始充电，112:停止充电，200:复位包裹处理机构，201:取件操作，202:寄件操作，203:卸货准备，204:卸货，205:上货，206:开存取件口，207:关存取件口||
|0x8001|uint8|读写|从机地址||1~247||
|0x8002|uint8|读写|波特率||0:4800，1:9600，2:19200，3:57600，4:115200||

**注：**
* 寄存器地址为16进制，实际Modbus报文中使用十进制地址（例如0x0001对应报文地址0001）。

# 6. 通信示例

## 读取保持寄存器（功能码0x03）
* **主站请求**  
    **01 03 00 00 00 02 C4 0B**  
    含义：读取从机地址1，起始地址0x0000（0），2个寄存器的值。
* **从机响应**  
    **01 03 04 00 0A 00 14 8A 12**  
    含义：返回4个字节数据（0x000A = 10，0x0014 = 20）。

# 7. 错误处理

## 7.1 异常响应格式
|字段|长度|说明|
|---|---|---|
|从机地址|1 Byte|设备地址|
|异常功能码|1 Byte|原功能码 + 0x80|
|异常码|1 Byte|错误类型（见下表）|
|CRC校验|2 Byte|校验码|

## 7.2 异常码列表
|异常码|名称|原因|
|---|---|---|
|0x01|Illegal Function|不支持的功能码|
|0x02|Illegal Data Address|无效寄存器地址|
|0x03|Illegal Data Value|数据值超出设备允许范围|

# 8. 附录

## 8.1 CRC16校验计算（示例代码）

* python
``` python
def crc16_modbus(data):
    crc = 0xFFFF
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 0x0001:
                crc >>= 1
                crc ^= 0xA001
            else:
                crc >>= 1
    return crc.to_bytes(2, 'little')
```

* java
``` java
public class CRC16Modbus {

    public static int calculateCRC16(byte[] data) {
        int crc = 0xFFFF; // 初始值
        for (byte b : data) {
            crc ^= (b & 0xFF); // 取低8位
            for (int i = 0; i < 8; i++) {
                if ((crc & 0x0001) != 0) {
                    crc >>= 1;
                    crc ^= 0xA001; // 多项式
                } else {
                    crc >>= 1;
                }
            }
        }
        return crc;
    }

    public static void main(String[] args) {
        byte[] data = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02}; // 示例数据
        int crc = calculateCRC16(data);
        System.out.printf("CRC16: 0x%04X\n", crc); // 输出：CRC16: 0xC40B
    }
}
```

* c
``` C
#include <stdio.h>
#include <stdint.h>

uint16_t calculateCRC16(uint8_t *data, uint16_t length) {
    uint16_t crc = 0xFFFF; // 初始值
    for (uint16_t i = 0; i < length; i++) {
        crc ^= (uint16_t)data[i]; // 取当前字节
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x0001) {
                crc >>= 1;
                crc ^= 0xA001; // 多项式
            } else {
                crc >>= 1;
            }
        }
    }
    return crc;
}

int main() {
    uint8_t data[] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x02}; // 示例数据
    uint16_t crc = calculateCRC16(data, sizeof(data));
    printf("CRC16: 0x%04X\n", crc); // 输出：CRC16: 0xC40B
    return 0;
}
```

## 8.2 参考文档
* Modbus协议规范：https://modbus.org/specs.php
* RS485标准：TIA/EIA-485-A